name: Issue to Project Integration

on:
  issues:
    types: [opened, labeled]

jobs:
  add-to-project:
    name: Add New Issue to Project Backlog
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'
    permissions:
      issues: write
      repository-projects: write
      projects: write
    steps:
      - name: Add issue to project
        id: add_project
        if: vars.GITHUB_PROJECT_URL != ''
        uses: actions/add-to-project@v0.5.0
        with:
          project-url: ${{ vars.GITHUB_PROJECT_URL }}
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT || secrets.GITHUB_TOKEN }}

      - name: Set project status to Backlog
        if: vars.GITHUB_PROJECT_NUMBER != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT || secrets.GITHUB_TOKEN }}
          env:
            GITHUB_PROJECT_NUMBER: ${{ vars.GITHUB_PROJECT_NUMBER }}
          script: |
            const org = context.repo.owner;
            const projectNumberRaw = process.env.GITHUB_PROJECT_NUMBER;
            if (!projectNumberRaw) {
              core.info('GITHUB_PROJECT_NUMBER nÃ£o definido. Pulando atualizaÃ§Ã£o de status no Project.');
              return;
            }

            const projectNumber = Number.parseInt(projectNumberRaw, 10);
            if (Number.isNaN(projectNumber)) {
              core.warning('GITHUB_PROJECT_NUMBER invÃ¡lido. Pulando atualizaÃ§Ã£o de status no Project.');
              return;
            }

            const issueNodeId = context.payload.issue.node_id;

            const projectData = await github.graphql(
              `query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    fields(first: 100) {
                      nodes {
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options {
                            id
                            name
                          }
                        }
                      }
                    }
                    items(first: 100) {
                      nodes {
                        id
                        content {
                          ... on Issue {
                            id
                            number
                          }
                        }
                      }
                    }
                  }
                }
              }`,
              { org, number: projectNumber }
            );

            const project = projectData.organization?.projectV2;
            if (!project) {
              core.setFailed('Projeto v2 nÃ£o encontrado.');
              return;
            }

            const statusField = project.fields.nodes.find(f => f?.name === 'Status');
            if (!statusField) {
              core.warning('Campo Status nÃ£o encontrado no projeto. Issue foi adicionada sem mover para Backlog.');
              return;
            }

            const backlogOption = statusField.options.find(o => o.name.toLowerCase() === 'backlog');
            if (!backlogOption) {
              core.warning('OpÃ§Ã£o Backlog nÃ£o encontrada no campo Status.');
              return;
            }

            const item = project.items.nodes.find(
              node => node?.content?.id === issueNodeId
            );

            if (!item) {
              core.warning('Item da issue ainda nÃ£o encontrado no projeto para definir Status=Backlog.');
              return;
            }

            await github.graphql(
              `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId,
                  itemId: $itemId,
                  fieldId: $fieldId,
                  value: { singleSelectOptionId: $optionId }
                }) {
                  projectV2Item {
                    id
                  }
                }
              }`,
              {
                projectId: project.id,
                itemId: item.id,
                fieldId: statusField.id,
                optionId: backlogOption.id,
              }
            );

            core.info(`Issue #${context.payload.issue.number} adicionada ao projeto com status Backlog.`);

  auto-label-by-template:
    name: Auto Label by Template
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'
    permissions:
      issues: write
    steps:
      - name: Add labels based on template
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const labels = [];

            // Adiciona label needs-triage para todas as novas issues
            labels.push('needs-triage');

            // Detecta tipo baseado no tÃ­tulo ou corpo
            const title = issue.title.toLowerCase();

            if (title.includes('[feature]') || title.includes('[feat]')) {
              labels.push('enhancement', 'feature');
            } else if (title.includes('[bug]')) {
              labels.push('bug');
            } else if (title.includes('[tech]')) {
              labels.push('technical');
            } else if (title.includes('[doc]')) {
              labels.push('documentation');
            } else if (title.includes('[test]')) {
              labels.push('testing', 'quality');
            }

            // Detecta prioridade no corpo da issue
            if (body.includes('P0') || body.includes('CrÃ­tica')) {
              labels.push('P0-critical');
            } else if (body.includes('P1') || body.includes('Alta')) {
              labels.push('P1-high');
            } else if (body.includes('P2') || body.includes('MÃ©dia')) {
              labels.push('P2-medium');
            } else if (body.includes('P3') || body.includes('Baixa')) {
              labels.push('P3-low');
            }

            // Detecta mÃ³dulo
            const modules = {
              'AutenticaÃ§Ã£o': 'auth',
              'Fornecedores': 'fornecedores',
              'Editais': 'editais',
              'Lotes': 'lotes',
              'Demandas': 'demandas',
              'Secretarias': 'secretarias',
              'OAuth': 'oauth',
              'Auditoria': 'auditoria',
              'Infraestrutura': 'infra'
            };

            for (const [name, label] of Object.entries(modules)) {
              if (body.includes(name)) {
                labels.push(label);
                break;
              }
            }

            // Adiciona as labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
            }

  auto-assign-sprint:
    name: Auto Assign to Current Sprint
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'
    permissions:
      issues: write
    steps:
      - name: Assign to sprint
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';

            // Adiciona comentÃ¡rio com informaÃ§Ãµes sobre sprint
            const comment = `ğŸ¯ **Issue criada com sucesso!**

            Esta issue foi automaticamente:
            - ğŸ“¥ Adicionada ao projeto no status **Backlog**
            - ğŸ·ï¸ Etiquetada baseada no template
            - ğŸ“‹ Marcada para triagem (\`needs-triage\`)

            **PrÃ³ximos passos:**
            1. O time farÃ¡ a revisÃ£o/triagem no backlog
            2. A issue serÃ¡ priorizada e refinada
            3. ApÃ³s definiÃ§Ã£o de sprint, seguirÃ¡ para execuÃ§Ã£o

            ğŸ“š Veja o [Setup rÃ¡pido do projeto](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${context.payload.repository.default_branch}/docs/SETUP_QUICK_START.md) para mais informaÃ§Ãµes.`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: comment
            });
